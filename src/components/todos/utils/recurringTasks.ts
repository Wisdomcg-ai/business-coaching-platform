// /src/components/todos/utils/recurringTasks.ts
// Utilities for managing recurring tasks

import type { Todo } from './types'

export interface RecurrencePattern {
  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly'
  interval: number // e.g., every 2 weeks
  daysOfWeek?: number[] // 0-6, Sunday-Saturday
  dayOfMonth?: number // 1-31
  monthOfYear?: number // 1-12
  endDate?: string
  occurrences?: number // limit number of occurrences
}

/**
 * Calculate the next occurrence date for a recurring task
 */
export function getNextOccurrence(
  lastDate: Date,
  pattern: RecurrencePattern
): Date | null {
  const next = new Date(lastDate)
  
  switch (pattern.frequency) {
    case 'daily':
      next.setDate(next.getDate() + pattern.interval)
      break
      
    case 'weekly':
      if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {
        // Find next occurrence on specified days
        let daysToAdd = 0
        let found = false
        
        for (let i = 1; i <= 7 * pattern.interval; i++) {
          const checkDate = new Date(lastDate)
          checkDate.setDate(checkDate.getDate() + i)
          
          if (pattern.daysOfWeek.includes(checkDate.getDay())) {
            daysToAdd = i
            found = true
            break
          }
        }
        
        if (found) {
          next.setDate(next.getDate() + daysToAdd)
        } else {
          return null
        }
      } else {
        next.setDate(next.getDate() + (7 * pattern.interval))
      }
      break
      
    case 'monthly':
      next.setMonth(next.getMonth() + pattern.interval)
      
      if (pattern.dayOfMonth) {
        // Set to specific day of month
        next.setDate(pattern.dayOfMonth)
        
        // Handle months with fewer days
        if (next.getDate() !== pattern.dayOfMonth) {
          // Day doesn't exist in this month (e.g., Feb 31)
          // Set to last day of month
          next.setDate(0) // Goes to last day of previous month
        }
      }
      break
      
    case 'quarterly':
      next.setMonth(next.getMonth() + (3 * pattern.interval))
      break
      
    case 'yearly':
      next.setFullYear(next.getFullYear() + pattern.interval)
      
      if (pattern.monthOfYear && pattern.dayOfMonth) {
        next.setMonth(pattern.monthOfYear - 1)
        next.setDate(pattern.dayOfMonth)
      }
      break
  }
  
  // Check if we've exceeded end date or occurrences
  if (pattern.endDate && next > new Date(pattern.endDate)) {
    return null
  }
  
  return next
}

/**
 * Generate upcoming occurrences for a recurring task
 */
export function generateOccurrences(
  startDate: Date,
  pattern: RecurrencePattern,
  count: number = 10
): Date[] {
  const occurrences: Date[] = []
  let currentDate = new Date(startDate)
  let generated = 0
  
  while (generated < count) {
    const next = getNextOccurrence(currentDate, pattern)
    
    if (!next) break
    
    occurrences.push(next)
    currentDate = next
    generated++
    
    // Safety check to prevent infinite loops
    if (generated > 100) break
  }
  
  return occurrences
}

/**
 * Create a new task from a recurring template
 */
export function createTaskFromRecurring(
  template: Todo,
  dueDate: Date
): Partial<Todo> {
  return {
    ...template,
    id: undefined, // Will be generated by database
    parent_task_id: template.id,
    due_date: dueDate.toISOString(),
    status: 'pending',
    completed_at: null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    is_recurring: false, // The instance is not recurring
    recurrence_pattern: null
  }
}

/**
 * Check if a task should generate a new occurrence
 */
export function shouldGenerateNextOccurrence(
  task: Todo,
  pattern: RecurrencePattern
): boolean {
  if (!task.is_recurring || !pattern) return false
  
  // Only generate next if current is completed
  if (task.status !== 'completed') return false
  
  // Check if we've reached occurrence limit
  if (pattern.occurrences) {
    // Would need to count existing occurrences in database
    // This is simplified - you'd query for count of tasks with parent_task_id
    return true
  }
  
  // Check if we've passed end date
  if (pattern.endDate && new Date() > new Date(pattern.endDate)) {
    return false
  }
  
  return true
}

/**
 * Parse recurrence pattern from natural language
 */
export function parseRecurrencePattern(text: string): RecurrencePattern | null {
  const lower = text.toLowerCase()
  
  // Daily patterns
  if (lower.includes('every day') || lower.includes('daily')) {
    return { frequency: 'daily', interval: 1 }
  }
  if (lower.includes('every other day')) {
    return { frequency: 'daily', interval: 2 }
  }
  
  // Weekly patterns
  if (lower.includes('every week') || lower.includes('weekly')) {
    return { frequency: 'weekly', interval: 1 }
  }
  if (lower.includes('every monday')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [1] }
  }
  if (lower.includes('every tuesday')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [2] }
  }
  if (lower.includes('every wednesday')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [3] }
  }
  if (lower.includes('every thursday')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [4] }
  }
  if (lower.includes('every friday')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [5] }
  }
  if (lower.includes('weekdays')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [1, 2, 3, 4, 5] }
  }
  if (lower.includes('weekends')) {
    return { frequency: 'weekly', interval: 1, daysOfWeek: [0, 6] }
  }
  
  // Monthly patterns
  if (lower.includes('every month') || lower.includes('monthly')) {
    return { frequency: 'monthly', interval: 1 }
  }
  if (lower.match(/every (\d+)(st|nd|rd|th)/)) {
    const match = lower.match(/every (\d+)/)
    if (match) {
      return { frequency: 'monthly', interval: 1, dayOfMonth: parseInt(match[1]) }
    }
  }
  
  // Quarterly
  if (lower.includes('quarterly') || lower.includes('every quarter')) {
    return { frequency: 'quarterly', interval: 1 }
  }
  
  // Yearly
  if (lower.includes('yearly') || lower.includes('annually') || lower.includes('every year')) {
    return { frequency: 'yearly', interval: 1 }
  }
  
  return null
}

/**
 * Format recurrence pattern for display
 */
export function formatRecurrencePattern(pattern: RecurrencePattern): string {
  const freq = pattern.frequency
  const interval = pattern.interval
  
  let base = ''
  
  if (interval === 1) {
    base = freq === 'daily' ? 'Daily' :
           freq === 'weekly' ? 'Weekly' :
           freq === 'monthly' ? 'Monthly' :
           freq === 'quarterly' ? 'Quarterly' :
           freq === 'yearly' ? 'Yearly' : ''
  } else {
    base = `Every ${interval} ${freq.replace('ly', '')}s`
  }
  
  // Add day specifications
  if (pattern.daysOfWeek && pattern.daysOfWeek.length > 0) {
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    const dayNames = pattern.daysOfWeek.map(d => days[d]).join(', ')
    base += ` on ${dayNames}`
  }
  
  if (pattern.dayOfMonth) {
    base += ` on the ${pattern.dayOfMonth}${getOrdinalSuffix(pattern.dayOfMonth)}`
  }
  
  if (pattern.endDate) {
    base += ` until ${new Date(pattern.endDate).toLocaleDateString()}`
  }
  
  if (pattern.occurrences) {
    base += ` (${pattern.occurrences} times)`
  }
  
  return base
}

function getOrdinalSuffix(day: number): string {
  if (day > 3 && day < 21) return 'th'
  switch (day % 10) {
    case 1: return 'st'
    case 2: return 'nd'
    case 3: return 'rd'
    default: return 'th'
  }
}